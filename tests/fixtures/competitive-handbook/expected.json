{
  "metadata": {
    "name": "competitive-handbook",
    "pageCount": 300,
    "language": "en",
    "title": "Competitive Programmer's Handbook",
    "author": "Antti Laaksonen",
    "creator": "LaTeX with hyperref package (pdfTeX)",
    "created": "2017-12-10"
  },
  "structure": {
    "headings": {
      "byLevel": {
        "h1": 6,
        "h2": 30,
        "h3": 120,
        "h4": 0,
        "h5": 0,
        "h6": 0
      },
      "items": [
        { "level": 1, "text": "Preface" },
        { "level": 1, "text": "Part I: Basic techniques" },
        { "level": 2, "text": "Chapter 1: Introduction" },
        { "level": 3, "text": "1.1 Programming languages" },
        { "level": 3, "text": "1.2 Input and output" },
        { "level": 3, "text": "1.3 Working with numbers" },
        { "level": 3, "text": "1.4 Shortening code" },
        { "level": 3, "text": "1.5 Mathematics" },
        { "level": 3, "text": "1.6 Contests and resources" },
        { "level": 2, "text": "Chapter 2: Time complexity" },
        { "level": 3, "text": "2.1 Calculation rules" },
        { "level": 3, "text": "2.2 Complexity classes" },
        { "level": 3, "text": "2.3 Estimating efficiency" },
        { "level": 3, "text": "2.4 Maximum subarray sum" },
        { "level": 2, "text": "Chapter 3: Sorting" },
        { "level": 3, "text": "3.1 Sorting theory" },
        { "level": 3, "text": "3.2 Sorting in C++" },
        { "level": 3, "text": "3.3 Binary search" },
        { "level": 2, "text": "Chapter 4: Data structures" },
        { "level": 3, "text": "4.1 Dynamic arrays" },
        { "level": 3, "text": "4.2 Set structures" },
        { "level": 3, "text": "4.3 Map structures" },
        { "level": 3, "text": "4.4 Iterators and ranges" },
        { "level": 3, "text": "4.5 Other structures" },
        { "level": 3, "text": "4.6 Comparison to sorting" },
        { "level": 2, "text": "Chapter 5: Complete search" },
        { "level": 3, "text": "5.1 Generating subsets" },
        { "level": 3, "text": "5.2 Generating permutations" },
        { "level": 3, "text": "5.3 Backtracking" },
        { "level": 3, "text": "5.4 Pruning the search" },
        { "level": 3, "text": "5.5 Meet in the middle" },
        { "level": 2, "text": "Chapter 6: Greedy algorithms" },
        { "level": 3, "text": "6.1 Coin problem" },
        { "level": 3, "text": "6.2 Scheduling" },
        { "level": 3, "text": "6.3 Tasks and deadlines" },
        { "level": 3, "text": "6.4 Minimizing sums" },
        { "level": 3, "text": "6.5 Data compression" },
        { "level": 2, "text": "Chapter 7: Dynamic programming" },
        { "level": 3, "text": "7.1 Coin problem" },
        { "level": 3, "text": "7.2 Longest increasing subsequence" },
        { "level": 3, "text": "7.3 Paths in a grid" },
        { "level": 3, "text": "7.4 Knapsack problems" },
        { "level": 3, "text": "7.5 Edit distance" },
        { "level": 3, "text": "7.6 Counting tilings" },
        { "level": 2, "text": "Chapter 8: Amortized analysis" },
        { "level": 3, "text": "8.1 Two pointers method" },
        { "level": 3, "text": "8.2 Nearest smaller elements" },
        { "level": 3, "text": "8.3 Sliding window minimum" },
        { "level": 2, "text": "Chapter 9: Range queries" },
        { "level": 3, "text": "9.1 Static array queries" },
        { "level": 3, "text": "9.2 Binary indexed tree" },
        { "level": 3, "text": "9.3 Segment tree" },
        { "level": 3, "text": "9.4 Additional techniques" },
        { "level": 2, "text": "Chapter 10: Bit manipulation" },
        { "level": 3, "text": "10.1 Bit representation" },
        { "level": 3, "text": "10.2 Bit operations" },
        { "level": 3, "text": "10.3 Representing sets" },
        { "level": 3, "text": "10.4 Bit optimizations" },
        { "level": 3, "text": "10.5 Dynamic programming" },
        { "level": 1, "text": "Part II: Graph algorithms" },
        { "level": 2, "text": "Chapter 11: Basics of graphs" },
        { "level": 3, "text": "11.1 Graph terminology" },
        { "level": 3, "text": "11.2 Graph representation" },
        { "level": 2, "text": "Chapter 12: Graph traversal" },
        { "level": 3, "text": "12.1 Depth-first search" },
        { "level": 3, "text": "12.2 Breadth-first search" },
        { "level": 3, "text": "12.3 Applications" },
        { "level": 2, "text": "Chapter 13: Shortest paths" },
        { "level": 3, "text": "13.1 Bellman-Ford algorithm" },
        { "level": 3, "text": "13.2 Dijkstra's algorithm" },
        { "level": 3, "text": "13.3 Floyd-Warshall algorithm" },
        { "level": 2, "text": "Chapter 14: Tree algorithms" },
        { "level": 3, "text": "14.1 Tree traversal" },
        { "level": 3, "text": "14.2 Diameter" },
        { "level": 3, "text": "14.3 All longest paths" },
        { "level": 3, "text": "14.4 Binary trees" },
        { "level": 2, "text": "Chapter 15: Spanning trees" },
        { "level": 3, "text": "15.1 Kruskal's algorithm" },
        { "level": 3, "text": "15.2 Union-find structure" },
        { "level": 3, "text": "15.3 Prim's algorithm" },
        { "level": 2, "text": "Chapter 16: Directed graphs" },
        { "level": 3, "text": "16.1 Topological sorting" },
        { "level": 3, "text": "16.2 Dynamic programming" },
        { "level": 3, "text": "16.3 Successor paths" },
        { "level": 3, "text": "16.4 Cycle detection" },
        { "level": 2, "text": "Chapter 17: Strong connectivity" },
        { "level": 3, "text": "17.1 Kosaraju's algorithm" },
        { "level": 3, "text": "17.2 2SAT problem" },
        { "level": 2, "text": "Chapter 18: Tree queries" },
        { "level": 3, "text": "18.1 Finding ancestors" },
        { "level": 3, "text": "18.2 Subtrees and paths" },
        { "level": 3, "text": "18.3 Lowest common ancestor" },
        { "level": 3, "text": "18.4 Offline algorithms" },
        { "level": 2, "text": "Chapter 19: Paths and circuits" },
        { "level": 3, "text": "19.1 Eulerian paths" },
        { "level": 3, "text": "19.2 Hamiltonian paths" },
        { "level": 3, "text": "19.3 De Bruijn sequences" },
        { "level": 3, "text": "19.4 Knight's tours" },
        { "level": 2, "text": "Chapter 20: Flows and cuts" },
        { "level": 3, "text": "20.1 Ford-Fulkerson algorithm" },
        { "level": 3, "text": "20.2 Disjoint paths" },
        { "level": 3, "text": "20.3 Maximum matchings" },
        { "level": 3, "text": "20.4 Path covers" },
        { "level": 1, "text": "Part III: Advanced topics" },
        { "level": 2, "text": "Chapter 21: Number theory" },
        { "level": 3, "text": "21.1 Primes and factors" },
        { "level": 3, "text": "21.2 Modular arithmetic" },
        { "level": 3, "text": "21.3 Solving equations" },
        { "level": 3, "text": "21.4 Other results" },
        { "level": 2, "text": "Chapter 22: Combinatorics" },
        { "level": 3, "text": "22.1 Binomial coefficients" },
        { "level": 3, "text": "22.2 Catalan numbers" },
        { "level": 3, "text": "22.3 Inclusion-exclusion" },
        { "level": 3, "text": "22.4 Burnside's lemma" },
        { "level": 3, "text": "22.5 Cayley's formula" },
        { "level": 2, "text": "Chapter 23: Matrices" },
        { "level": 3, "text": "23.1 Operations" },
        { "level": 3, "text": "23.2 Linear recurrences" },
        { "level": 3, "text": "23.3 Graphs and matrices" },
        { "level": 2, "text": "Chapter 24: Probability" },
        { "level": 3, "text": "24.1 Calculation" },
        { "level": 3, "text": "24.2 Events" },
        { "level": 3, "text": "24.3 Random variables" },
        { "level": 3, "text": "24.4 Markov chains" },
        { "level": 3, "text": "24.5 Randomized algorithms" },
        { "level": 2, "text": "Chapter 25: Game theory" },
        { "level": 3, "text": "25.1 Game states" },
        { "level": 3, "text": "25.2 Nim game" },
        { "level": 3, "text": "25.3 Sprague-Grundy theorem" },
        { "level": 2, "text": "Chapter 26: String algorithms" },
        { "level": 3, "text": "26.1 String terminology" },
        { "level": 3, "text": "26.2 Trie structure" },
        { "level": 3, "text": "26.3 String hashing" },
        { "level": 3, "text": "26.4 Z-algorithm" },
        { "level": 2, "text": "Chapter 27: Square root algorithms" },
        { "level": 3, "text": "27.1 Combining algorithms" },
        { "level": 3, "text": "27.2 Integer partitions" },
        { "level": 3, "text": "27.3 Mo's algorithm" },
        { "level": 2, "text": "Chapter 28: Segment trees revisited" },
        { "level": 3, "text": "28.1 Lazy propagation" },
        { "level": 3, "text": "28.2 Dynamic trees" },
        { "level": 3, "text": "28.3 Data structures" },
        { "level": 3, "text": "28.4 Two-dimensionality" },
        { "level": 2, "text": "Chapter 29: Geometry" },
        { "level": 3, "text": "29.1 Complex numbers" },
        { "level": 3, "text": "29.2 Points and lines" },
        { "level": 3, "text": "29.3 Polygon area" },
        { "level": 3, "text": "29.4 Distance functions" },
        { "level": 2, "text": "Chapter 30: Sweep line algorithms" },
        { "level": 3, "text": "30.1 Intersection points" },
        { "level": 3, "text": "30.2 Closest pair problem" },
        { "level": 3, "text": "30.3 Convex hull problem" },
        { "level": 1, "text": "Bibliography" },
        { "level": 1, "text": "Index" }
      ]
    },
    "hierarchyValid": true
  },
  "content": {
    "images": {
      "count": 348,
      "minDimensions": { "width": 50, "height": 50 }
    },
    "tables": {
      "count": 65
    },
    "codeBlocks": {
      "count": 209,
      "languages": ["cpp"]
    }
  },
  "format": {
    "shouldParse": true
  }
}
